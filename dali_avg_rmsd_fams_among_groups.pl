#!/usr/bin/env perl
#
# created on: 19/Jan/2011 by M.Alonso
# 
# This script generates a DATA FILE  with the AVG RMSD of the structural superpositions of all vs all families in HPKDs 
# This script must be executed from the folder that contains the among-groups fams.vs.fams str.alignments.
# This script needs access to the corresponding DATA FILEs of AVG RMSD generated by within-groups str.alignments.
# After executing this script in order to generate the heatmaps you need to execute "Rheatmaps.R"
#
# ######
# INPUT: 
# - hpkd_db
# - Summary files generated by  batch_prepare_dalilite_scripts_fams_among_groups.pl
# - DATA files with AVG RMSD from within-groups str.alignments.
#
# OUTPUT:
# - a DATA file containing the AVG RMSD for all vs all HPK families with at least one R3DS available
######

use DBI;
use strict;
use warnings;
use File::Find;

## Define the HPK Groups to be processed
my @hpk_groups= qw(AGC CAMK CK1 CMGC Other STE TK TKL Atypical);
my @summary_files=();

## Defining dir where to look for avg_rmsd data from within-groups fam vs fam comparisons
my $within_groups_comp_dir = "/aloy/scratch/malonso/test/daliLite/in-groups_Fam_vs_Fam/";

my %real_structures_in_fam=(); # {fam}=Numb.R3DS
my %g1_f1_g2_f2_rmsds=(); # {g1}{f1}{g2}{f2}=[rmsds]
my %g1_f1_g2_f2_avg_rmsd=(); # {g1}{f1}{g2}{f2}=$avg_rmsd

my $ini_dir=`pwd`;
chomp($ini_dir);

## backup and remove old datafile if exists
my $outfile=$ini_dir."/DALI_AVG_RMSD.dat";
if(-e $outfile){
  system("cp $outfile DALI_AVG_RMSD.dat.backup");
  unlink($outfile);
}

##############################
## Fetching the number of R3DS per HPK family in all groups
%real_structures_in_fam=real_structures_per_fam();
#print "$_\t$real_structures_in_fam{$_}\n" foreach(sort {$real_structures_in_fam{$b}<=>$real_structures_in_fam{$a}} keys %real_structures_in_fam);
##############################


##############################
## Iterating through HPK group comparison pairs
foreach my $g (@hpk_groups){
  @summary_files=();
  %g1_f1_g2_f2_rmsds=();
  %g1_f1_g2_f2_avg_rmsd=();
  ## Defining file where to look for avg_rmsd data from within-groups fam vs fam comparisons
  my $within_groups_rmsds_file = $within_groups_comp_dir.$g."/".$g."_dali_avg_rmsd_fams_in_group.dat";

  print "processing group $g\n";
  
  ## Independently processing Atypical group since is the last in the group array.
  if($g eq "Atypical"){
    open(F,$within_groups_rmsds_file) or die;
    open(DATA,">>$outfile") or die;
    while(<F>){
      my @tmp=split("\t",$_);
      print DATA "$g\t$tmp[0]\t$g\t$tmp[1]\t$tmp[2]\n"
    }
    close(DATA);
    close(F);
    next;
  }
  
  ## moving into current group's dir
  my $change_dir=$ini_dir."/".$g."/";
  chdir($change_dir) or die;

  ## retrieve full paths of summary files in current group's dir
  print "\tretrieving summary paths\n";
  retrieve_summary_paths($change_dir);
  
  ## parsing summary files and loading the rmsd values into an array
  print "\tloading rmsd values\n";
  foreach my $file (@summary_files){
    parse_summary_load_rmsd($file);
  }
  
  ### averaging flex_rmsd values
  print "\taveraging rmsd values\n";
  %g1_f1_g2_f2_avg_rmsd = avg_rmsd(\%g1_f1_g2_f2_rmsds);
  
  ### Renaming the families keys by appending the corresponding R3DS number available for the family
  %g1_f1_g2_f2_avg_rmsd = renaming_families_keys_names(\%g1_f1_g2_f2_avg_rmsd,\%real_structures_in_fam);
  
  ### Appending within group avg_rmsd values to among groups hash
  print "\tappending within-groups avg rmsd values\n";
  %g1_f1_g2_f2_avg_rmsd = append_within_group_avg_rmsd_values(\%g1_f1_g2_f2_avg_rmsd,$within_groups_rmsds_file,$g);
  
  ### printing to DATA file
  print "\tprinting to data file\n";
  printout_avg_rmsd_hash(\%g1_f1_g2_f2_avg_rmsd);
  
  ## return to initial directory
  chdir($ini_dir) or die;
}
##############################


##############################
#### SUBROUTINES #############
##############################

#############################
sub retrieve_summary_paths{
  my $current_dir="";
  $current_dir = $_[0];
  find(\&files_paths, $current_dir);
}
#############################

#############################
sub files_paths{
  my $elemento = $_;
  chomp($elemento);
  #if (-f $elemento && $elemento =~ /summary/ ){
  if (-f $elemento && $elemento eq "summary.txt"){
    push(@summary_files,$File::Find::name);
  }
}
#############################

#############################
## Parsing Summary files and Loading the RMSD values into the corresponding hash 
## RMSD values are pushed into an array assigned to the corresponding {g1}{f1}{g2}{f2}=RMSD
##
sub parse_summary_load_rmsd{
  my $file = $_[0];
  chomp($file);
  my (@fields,@prot1,@prot2)=();
  my ($group1, $fam1, $group2, $fam2, $summary_dir_name,$rmsd,$zscore)="";
  my $summary_file_line=1;
  
  ## retrieving current families' names
  $summary_dir_name = `dirname $file`;
  chomp($summary_dir_name);
  @fields = split("/",$summary_dir_name);
  $summary_dir_name = $fields[-1];
  @fields = split("_vs_",$summary_dir_name); # TKL_IRAK__IRAK4_2nryB_vs_Atypical_PDHK__PDHK1_2q8gA
  @prot1 = split("_",$fields[0]);
  @prot2 = split("_",$fields[1]);
  ($group1, $fam1, $group2, $fam2)=($prot1[0],$prot1[1],$prot2[0],$prot2[1]);
  
  ## retrieving rmsd values & pushing them into an array
  open(I,$file) or die;
  while(<I>){
    if($summary_file_line == 3){
      chomp();  
      @fields = split(' +',$_);
      ## Cheking if Z-value & RMSD values exists in summary.txt file && 
      ## cheking if Z-value >= 2 ("Similarities with a Z-score lower than 2 are spurious", ekhidna.biocenter.helsinki.fi/dali_server)
      if($#fields > 0 && defined $fields[3] && defined $fields[4] && $fields[3]>=2){
        $rmsd = $fields[4];
        $zscore = $fields[3];
      }else{
        # For structures that Dali fails to compute the rmsd RAPIDO assigns rigid rmsd > 10 Angstroms,
        # following this I assign the arbitrary value of 20 Angstrom of RMSD for those structures pairs that Dali fails to compute RMSD.
        $rmsd = 20;
        $zscore = 0;
      }# print "$group1, $fam1, $prot1[3], $prot1[4] - $group2, $fam2, $prot2[3], $prot2[4]: $zscore $rmsd\n";
      push(@{$g1_f1_g2_f2_rmsds{$group1}{$fam1}{$group2}{$fam2}},$rmsd);
      last;  
    }else{
      $summary_file_line++;
    }
  }
  close(I);
}
#############################

#############################
## Calculating the AVG RMSD among families across HPK groups
## 
sub avg_rmsd{
  my %hash = %{$_[0]};
  my %return_hash;
  
  foreach my $g1 (sort {$a cmp $b} keys %hash){
    
    my @f1 = sort {$a cmp $b} keys %{$hash{$g1}};
    
    foreach my $f1 (sort {$a cmp $b} keys %{$hash{$g1}}){
      ### artifact for setting to Zero the avg(flex_rmsd) amongst families in the same group
      ##foreach my $ff1 (sort {$a cmp $b} keys %{$hash{$g1}}){$return_hash{$g1}{$f1}{$g1}{$ff1}=0.0000;}
      #foreach (@f1){
        #$return_hash{$g1}{$f1}{$g1}{$_}=0.0000;
        ##shift(@f1);
      #}
      #shift(@f1);
      foreach my $g2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}}){
        foreach my $f2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}{$g2}}){
          my ($total,$avg_rmsd,$elements)=0;
          $elements = scalar @{$hash{$g1}{$f1}{$g2}{$f2}};
          $total+=$_ foreach(@{$hash{$g1}{$f1}{$g2}{$f2}});
          $avg_rmsd = $total/$elements;
          $return_hash{$g1}{$f1}{$g2}{$f2}=$avg_rmsd;
        }
      }
    }
  }
  return (%return_hash);
}
#############################

#############################
## 
sub printout_avg_rmsd_hash{
  my %hash_print = %{$_[0]};
  
  open(DATA, ">>$outfile") or die;
  
  foreach my $g1 (sort {$a cmp $b} keys %hash_print){
    foreach my $f1 (sort {$a cmp $b} keys %{$hash_print{$g1}}){
      #print DATA "\n";
      foreach my $g2 (sort {$a cmp $b} keys %{$hash_print{$g1}{$f1}}){
        ## By now skip Atypical group, print it later.
        next if ($g2 eq "Atypical");
        foreach my $f2 (sort {$a cmp $b} keys %{$hash_print{$g1}{$f1}{$g2}}){
          print DATA "$g1\t$f1\t$g2\t$f2\t";
          printf DATA ("%.4f\n",$hash_print{$g1}{$f1}{$g2}{$f2});
        }
      }
      #####################
      # now print Atypical group
      foreach my $g2 (sort {$a cmp $b} keys %{$hash_print{$g1}{$f1}}){
        if ($g2 eq "Atypical"){
          foreach my $f2 (sort {$a cmp $b} keys %{$hash_print{$g1}{$f1}{$g2}}){
            print DATA "$g1\t$f1\t$g2\t$f2\t";
            printf DATA ("%.4f\n",$hash_print{$g1}{$f1}{$g2}{$f2});
            last;
          }
        }else{;}
      }
      #####################
      print DATA "\n";
    }
  }
  print DATA "\n";
  close(DATA);
}
#############################

##############################
## Counting real structures in HPK Fams
## Returns: hash containing {fam}=numb_real_structures
## 
sub real_structures_per_fam{
  my %fam_str_count;
  
  ######
  ## connecting DB
  my $conn = DBI->connect("dbi:Pg:dbname=hpkd_db;host=localhost;port=5433;user=malonso;password='manuel'");
  ## querying DB for fam real structures
  my $query = $conn->prepare("SELECT distinct(hpkd_family), count(distinct(template_file)) as rs FROM hpkd_templates_realseq WHERE need_to_model='no' GROUP BY hpkd_family ORDER BY rs DESC")or die $conn->errstr;
  $query->execute() or die $conn->errstr;
  ## fetching names of fam & numb of real structures
  while(my @row = $query->fetchrow_array()){
    $fam_str_count{$row[0]}=$row[1];
  }
  ## disconnecting DB
  $conn->disconnect();
  ######
  
  return %fam_str_count;
}
##############################

##############################
## In situ hash keys renaming
##
sub rename_key {
 my $hashref = shift;
 my $oldkey  = shift;
 my $newkey  = shift;
 $hashref->{$newkey} = delete $hashref->{$oldkey};
}
##############################

##############################
## Renaming the families keys in %g1_f1_g2_f2_avg_rmsd by adding the corresponding R3DS number {FamA_(No.R3DS)}
##
## Arguments:
## 1) hash to be renamed (%g1_f1_g2_f2_avg_rmsd)
## 2) hash containing the number of R3DS per HPK family (%real_structures_in_fam)
## 
## Returns:
## The hash of argument 1 (%g1_f1_g2_f2_avg_rmsd) with families keys renamed
##
sub renaming_families_keys_names{
  my %renamedkeys=%{$_[0]};
  my %fam_str_count=%{$_[1]};
  my ($g1,$f1,$g2,$f2,$newkey)="";
  
  ## Renaming the keys in %fam_comp_flex_rmsd by adding the corresponding R3DS number
  ## Renaming f1 keys {g1}{f1}
  foreach $g1 (keys %renamedkeys){
    foreach $f1 (keys %{$renamedkeys{$g1}}){
      $newkey=$f1."_(".$fam_str_count{$f1}.")";
      rename_key( \%{$renamedkeys{$g1}}, $f1, $newkey);
    }
  }
  foreach $g1 (keys %renamedkeys){
    foreach $f1 (keys %{$renamedkeys{$g1}}){
      foreach $g2 (keys %{$renamedkeys{$g1}{$f1}}){
        foreach $f2 (keys %{$renamedkeys{$g1}{$f1}{$g2}}){
          my $newkey=$f2."_(".$fam_str_count{$f2}.")";
          rename_key( \%{$renamedkeys{$g1}{$f1}{$g2}}, $f2, $newkey);
        }
      }
    }
  }

  ## Debugging printing of data structure in %renamedkeys
  #foreach $g1 (keys %renamedkeys){
    #foreach $f1 (keys %{$renamedkeys{$g1}}){
      #foreach $g2 (keys %{$renamedkeys{$g1}{$f1}}){
        #foreach $f2 (keys %{$renamedkeys{$g1}{$f1}{$g2}}){
          #print "$g1\t$f1\t$g2\t$f2\n";
        #}
      #}
    #}
  #}
  
  return %renamedkeys;
  
}
##############################

##############################
sub append_within_group_avg_rmsd_values{
  my %g1_f1_g2_f2_avg_rmsd = %{$_[0]};
  my $within_groups_rmsds_file = $_[1];
  my $group = $_[2];

  open(F,$within_groups_rmsds_file) or die;
  while(<F>){
    chomp();
    if($_ eq ""){
      next;
    }else{
      my @fields = split("\t",$_); ## FAM1_(R3DS) FAM2_(R3DS) AVGRMSD
      $g1_f1_g2_f2_avg_rmsd{$group}{$fields[0]}{$group}{$fields[1]}=$fields[2];
    }
  }
  close(F);
  
  return %g1_f1_g2_f2_avg_rmsd;
}
##############################













