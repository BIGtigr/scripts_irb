#!/usr/bin/env perl
#
# 18/Jan/2010 by MAlonso
#
# Processing DALI's summary.txt output files from the pairwise structural superposition of R3DS.hpkds
# among families of the same HPK group.
#
# The script generates (for each family pairwise comparison):
#   - a gnuplot data file
#   - a gnuplot script file
#   - a heatmap.eps file
#
# The script's sequence of actions is:
# Reading summary files of all structural superpositions. 
# Generating the corresponding gnuplot data files & script files.
# Executing gnuplot script files
#
# This script is intended to be used after performing all the struc.aligments with DALI (script: "batch_prepare_DALI_scripts.pl").
# This script must be executed from the folder that contains the folder directories structure created by "batch_prepare_DALI_scripts.pl"
#
# For more info read the README file present in the same folder afore mentioned.
#
######
# INPUT: 
# summary.txt files generated by DALI after each protA vs protB structural superposition
#
# OUTPUT:
# The script generates (for each family pairwise comparison):
#   - data file
#   - a gnuplot script file
#   - a heatmap.eps file
######
#
use strict;
use warnings;
use File::Find;


## RGC neither Atypical groups were included in the current analysis
## due to they only contain one family (or none) for which Real3DStrs are
## available (histogram: dist_strs-templs_per_hpkfamily.pdf)
my @hpk_groups= qw(AGC CAMK CK1 CMGC Other STE TK TKL Atypical);
my (@fam1,@fam2);
my %strs_rmsd=();
my @summary_files=();

my $ini_dir=`pwd`;
chomp($ini_dir);


## iterating trough each HPK group
foreach my $group (@hpk_groups){
  print "processing group $group\n";
  my @fam_comp_folders;
  ## moving into current GROUP directory
  my $change_dir=$ini_dir."/".$group."/";
  chdir($change_dir) or die;
  #system ("pwd");
  
  ## loading families comparison folders 
  opendir(DIR, $change_dir) or die "cant find $change_dir: $!";
  while (defined(my $file = readdir(DIR))) {
    #next if $file =~ /^\.\.?$/;
    next if ($file eq "." || $file eq ".." ) ;
    push @fam_comp_folders,"$change_dir$file" if (-d "$change_dir$file");
  }#print "$_\n" foreach (@fam_comp_folders);
  closedir(DIR);  
  
  foreach my $folder (@fam_comp_folders){
    ## defining data structure for storing the rmsd values of each fam-fam struc superposition
    %strs_rmsd=(); # {FamA-ProtX}{FamB-ProtY}=rmsd
    @summary_files=();
    my $current_dir="";
    my ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_rmsd, $min_rmsd, $FamA_name, $FamB_name) = "";
    ## cd into current $foder of family comp pair
    chdir($folder);
    ## retrieve the current full path
    $current_dir=`pwd`;
    chomp($current_dir);
    
    ### Retrieve full paths of summary files $current_dir of family comp pairs
    ### Storing them in @summary_files
    retrieve_summary_paths($current_dir);
    
    ## Parsing summary files and creating Gnuplot DATA file
    unless($#summary_files>=0){
      print "\t\t not enough structures for alignments. Skipping current comparision folder\n";
      next;
    }
    ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_rmsd, $min_rmsd, $FamA_name, $FamB_name) = parse_summary_create_gnuplot_datafile(@summary_files);
    #generate_gnuplot_script($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_rmsd, $min_rmsd, $FamA_name, $FamB_name, $group);
    
    ## execute gnuplot scripts
    #system("gnuplot GNUPLOT_SCRIPT.gplot");

    ## go back one dir
    chdir("../");
    #system ("pwd");
  }
  ## go back to starting directory
  chdir($ini_dir);
  #system ("pwd");
}


##############################
#### SUBROUTINES #############
##############################

#############################
sub retrieve_summary_paths{
  my $current_dir="";
  $current_dir = $_[0];
  find(\&files_paths, $current_dir);
}
#############################

#############################
sub files_paths{
  my $elemento = $_;
  chomp($elemento);
  #if (-f $elemento && $elemento =~ /summary/ ){
  if (-f $elemento && $elemento eq "summary.txt"){
    push(@summary_files,$File::Find::name);
  }
}
#############################


#############################
## Parsing  files & creating GnuPlot Data file
##
sub parse_summary_create_gnuplot_datafile{
  # pase summary files and fill hash {str1}{str2}=rmsd
  my @summaries = @_;
  my (@fields,@prot1,@prot2);
  my ($rmsd,$prot1,$prot2,$FamA_name,$FamB_name);
  my ($indexA,$indexB,$prots_in_FamA,$prots_in_FamB)=0;
  my $xtics="";
  my $ytics="";
  my $max_rmsd=-1;      ## I'm currently collecting max & min rmsd but I'm not using them.
  my $min_rmsd=999999;  ## They were/are intended to be used for setting the min-max threshold of cbrange (color-box range).
  
  
  open(DATAFILE,">RMSD_DATA_FILE.dat") or die;
  
  foreach my $summary_file (@summaries){    
    my $summary_file_line=1;
    my $summary_dir_name="";
    chomp($summary_file);
    
    ## retrieving rmsd values
    open(I,$summary_file) or die;
    while(<I>){
      ## grabbing the rmsd value in the 3rd line of summary file
      if($summary_file_line == 3){
        chomp();  
        @fields = split(' +',$_);
        if($#fields > 0 && defined $fields[3] && defined $fields[4] && $fields[3]>=2){
          ## Cheking if Z-value & RMSD values exists in summary.txt file && 
          ## cheking if Z-value >= 2 ("Similarities with a Z-score lower than 2 are spurious", ekhidna.biocenter.helsinki.fi/dali_server)
          $rmsd = $fields[4];
        }else{
          # For structures that Dali fails to compute the rmsd RAPIDO assigns rigid rmsd > 10 Angstroms,
          # following this I assign the arbitrary value of 15 Angstrom of RMSD for those structures pairs that Dali fails to compute RMSD.
          $rmsd = 15;
        }
        $max_rmsd = $rmsd if($rmsd > $max_rmsd);
        $min_rmsd = $rmsd if($rmsd < $min_rmsd);
        last;  
      }else{
        $summary_file_line++;
      }
    }
    close(I);
    
    ## retrieving current families' names
    $summary_dir_name = `dirname $summary_file`;
    chomp($summary_dir_name);
    @fields = split("/",$summary_dir_name);
    $summary_dir_name = $fields[-1];
    @fields = split("_vs_",$summary_dir_name);
    # G_F_SF_PK_PDB
    @prot1 = split("_",$fields[0]);
    @prot2 = split("_",$fields[1]);
    $prot1 = join("_-",@prot1[3..4]);
    $prot2 = join("_-",@prot2[3..4]);
    $strs_rmsd{$prot1}{$prot2}=$rmsd;
    $FamA_name=$prot1[1];
    $FamB_name=$prot2[1];    
  }
  
  foreach my $k1 (sort {$a cmp $b} keys %strs_rmsd){
    $xtics=$xtics."\"$k1\" $indexA,";
    $indexB=0;
    $ytics="";
    #unless((keys %strs_rmsd)>1){$indexA++; $xtics=$xtics."\"\" $indexA,";}
    foreach my $k2 (sort {$a cmp $b} keys %{$strs_rmsd{$k1}}){
      $ytics=$ytics."\"$k2\" $indexB,";
      #unless((keys %{$strs_rmsd{$k1}})>1){$indexB++; $ytics=$ytics."\"\" $indexB,";}
      print DATAFILE "$FamA_name\t$k1\t$FamB_name\t$k2\t$indexA\t$indexB\t$strs_rmsd{$k1}{$k2}\n";
      ### dealing with families with only 1 Real3DStr
      unless((keys %strs_rmsd)>1){
        #$indexA;
        #$xtics=$xtics."\"$k1\" $indexA,";
        print DATAFILE "$FamA_name\t----------\t$FamB_name\t$k2\t1\t$indexB\t0.00\n\n";
      }
      ### dealing with families with only 1 Real3DStr
      unless((keys %{$strs_rmsd{$k1}})>1){
        #$indexB++;
        #$ytics=$ytics."\"$k2\" $indexB,";
        print DATAFILE "$FamA_name\t$k1\t$FamB_name\t----------\t$indexA\t1\t0.00\n\n";
      }
      $indexB++;
    }
    $indexA++;
    print DATAFILE "\n";
  }
  chop($xtics);
  chop($ytics);
  $prots_in_FamA=$indexA;
  $prots_in_FamB=$indexB;
  #print "famA: $prots_in_FamA\n";
  #print "famB: $prots_in_FamB\n";
  #print "max rmsd: $max_rmsd\n";
  #print "min rmsd: $min_rmsd\n";
  #print "xtics: $xtics\n";
  #print "ytics: $ytics\n";
  close(DATAFILE);
  
  
  return($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_rmsd, $min_rmsd, $FamA_name, $FamB_name);
}
#############################

#############################
## Creating GnuPlot Script file
##
sub generate_gnuplot_script{
  my $gnuplot_template="/home/malonso/phd/kinome/scripts/heatmaps_flex-rmsd_prots-in-families_TEMPLATE.gplot";
  my ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_rmsd, $min_rmsd, $FamA_name, $FamB_name, $group) = @_;
  
  open(GNUPLOT,$gnuplot_template) or die;
  my @gnuplot_template=<GNUPLOT>;
  close(GNUPLOT);
  
  open(GNUPLOT_SCRIPT,">GNUPLOT_SCRIPT.gplot") or die;
  
  my @gnuplot_template_cp = @gnuplot_template;
  
  foreach (@gnuplot_template_cp){
    if(/HPK-GROUP/){
      s/HPK-GROUP/$group/;
    }elsif(/FAMILY-A/){
      s/FAMILY-A/$FamA_name/;
    }elsif(/XTICS_LABELS/){
      s/XTICS_LABELS/$xtics/;
    }elsif(/XTOP_VALUE/){
      $prots_in_FamA = $prots_in_FamA - 0.5;
      s/XTOP_VALUE/$prots_in_FamA/;
    }elsif(/FAMILY-B/){
      s/FAMILY-B/$FamB_name/;
    }elsif(/YTICS_LABELS/){
      s/YTICS_LABELS/$ytics/;
    }elsif(/YTOP_VALUE/){
      $prots_in_FamB = $prots_in_FamB - 0.5;
      s/YTOP_VALUE/$prots_in_FamB/;
    #}elsif(/_RMSD_VALUE/){
      #$min_rmsd = $min_rmsd - 0.05;
      #s/BOTTOM_RMSD_VALUE/$min_rmsd/;
      #$max_rmsd = $max_rmsd + 0.05;
      #s/TOP_RMSD_VALUE/$max_rmsd/;
    }elsif(/HEAT_MAP_NAME/){
      my $heat_map = $FamA_name."_vs_".$FamB_name;
      s/HEAT_MAP_NAME/$heat_map/;
    }
    print GNUPLOT_SCRIPT "$_";
  }
  
  close(GNUPLOT_SCRIPT);
}
#############################



