#!/usr/bin/env perl
#
# Dic.2010. by MAlonso
# 
# This script generates datafiles with the AVG(flex_rmsd) among families in a Group.
# The datafiles (.Rdat) will be used by the script "Rheatmaps.R" (by D.Rossell).
# Data & Heatmaps files are automatically created under each HPK group.
# This script must be executed from the folder that contains within groups family vs. family str.alignments.
#
# After executing this script in order to generate the heatmaps you need to execute "Rheatmaps.R"
#
# ######
# INPUT: 
# RMSD DATA FILEs generated by "heatmaps_flex-rmsd_prots-in-families.pl"
#
# OUTPUT:
# The script generates (for each group) a file containing the AVG(rmsd) of each family vs family pairwise comparison:
#
# USAGE:
# execute this script from the folder containing the HPK Groups folders
######
#
#

use DBI;
use strict;
use warnings;
use List::MoreUtils qw(uniq);

#my @hpk_groups= qw (AGC CAMK CK1 CMGC Other STE TK TKL Atypical);


my $ini_dir=`pwd`;
chomp($ini_dir);

## iterating trough each HPK group
foreach my $group (@hpk_groups){
  print "processing group $group\n\n";
  my @fam_comp_folders=();
  my %fam_comp_flex_rmsd=(); ##{fam1}{fam2}=avg_flex_rmsd
  my @fams=();
  ## moving into current GROUP directory
  my $change_dir=$ini_dir."/".$group."/";
  chdir($change_dir) or die;
  #system ("pwd");
  
  ## loading families comparison folders 
  opendir(DIR, $change_dir) or die "cant find $change_dir: $!";
  while (defined(my $file = readdir(DIR))) {
    #next if $file =~ /^\.\.?$/;
    next if ($file eq "." || $file eq ".." ) ;
    push @fam_comp_folders,"$change_dir$file" if (-d "$change_dir$file");
  }#print "$_\n" foreach (@fam_comp_folders);
  closedir(DIR);
  
  ## averaging flex_rmsd values from each RMSD DATA FILEs in families comparison folders
  foreach my $fam_com (@fam_comp_folders){
    my @data=();
    my ($avg,$i,$sum)=0;
    my ($fam1,$fam2)="";
    #my $datafile = $fam_com."/"."GNUPLOT_DATA_FILE.dat";
    #my $datafile = $fam_com."/"."GNUPLOT_DATA_FILE_RIGID_RMSD.dat";
    my $datafile = $fam_com."/"."RMSD_DATA_FILE.dat";
    
    print "$fam_com\n";

    if(-z $datafile || ! -e $datafile){ ## If file is empty or absent, assing Zero to the avg rmsd
    ## An empty or unexistent means that there are not enough structures (i.e only 1) for performing an alignemnt 
      $fam_com =~ /\/(\w+)_vs_(\w+)$/;
      ($fam1,$fam2)=($1,$2);
      $avg=0;
    }else{
      open(DATA,$datafile) or warn;
      while(<DATA>){
        chomp();
        next if($_ eq "");
        @data = split('\s+',$_) if($_ ne "");
        if($data[6] ne "" && $data[6] > 0.00){
          $i++;
          $sum += $data[6];
          ($fam1,$fam2)=($data[0],$data[2]);
        }
      }
      close(DATA);
      $avg = $sum/$i;
    }
    
    push(@fams,$fam1,$fam2);
    $fam_comp_flex_rmsd{$fam1}{$fam2}=$avg;
    #print "\t$fam1 - $fam2\t$fam_comp_flex_rmsd{$fam1}{$fam2}\n";
  }
  @fams = uniq(@fams);
  @fams =  sort {lc $a cmp lc $b} @fams; # case-insensitive sort
  
  ## Counting Real Structures in current Group's families
  count_real_structures_in_fam(\$group,\@fams);
  ## creating the Data File
  create_data_file(\@fams,\%fam_comp_flex_rmsd,\$group);
  
}

##############################
#### SUBROUTINES #############
##############################

##############################
##
## Creating the datafiles for R.
## The R script "Rheatmaps.R" need to be executed for generating the heatmaps
## 
sub create_data_file{
  my @fams = @{$_[0]};
  my %fam_comp_flex_rmsd = %{$_[1]};
  my %fam_str_count;
  my $group = ${$_[2]};
  my $rdatafile = $group."_dali_avg_rmsd_fams_in_group.dat";
  
  ##############
  ## Counting the number of R3DS in each family for later renaming the 
  ## keys in %fam_comp_flex_rmsd by adding the corresponding R3DS number
  %fam_str_count = count_real_structures_in_fam(\$group,\@fams);
  ## Renaming the keys in %fam_comp_flex_rmsd by adding the corresponding R3DS number
  ## Outer keys {k1}
  foreach my $k1 (keys %fam_comp_flex_rmsd){
    my $newkey1=$k1."_(".$fam_str_count{$k1}.")";
    rename_key( \%fam_comp_flex_rmsd, $k1, $newkey1);
  }
  ## Inner keys {k1}{k2}
  foreach my $k1 (keys %fam_comp_flex_rmsd){
    foreach my $k2 (keys %{$fam_comp_flex_rmsd{$k1}}){
      my $newkey2=$k2."_(".$fam_str_count{$k2}.")";
      rename_key( \%{$fam_comp_flex_rmsd{$k1}}, $k2,$newkey2);
    }
  }
  ## Renaming elements in @fams array
  for(my $i=0;$i <= $#fams;$i++){
    $fams[$i] =  $fams[$i]."_(".$fam_str_count{$fams[$i]}.")" if(exists $fam_str_count{$fams[$i]});
  }
  ##############
  
  open(RDATA,">$rdatafile") or die;
  
  for(my $i=0; $i<=$#fams;$i++){
    printf RDATA ("%s\t%s\t%.3f\n",$fams[$i],$fams[$i],$fam_comp_flex_rmsd{$fams[$i]}{$fams[$i]});
    last if($#fams==0); ## If there's only one family, print its avg(rmsd) and leave
    for(my $ii = $i+1; $ii<=$#fams; $ii++){
      if(exists $fam_comp_flex_rmsd{$fams[$i]}{$fams[$ii]}){
        printf RDATA ("%s\t%s\t%.3f\n",$fams[$i],$fams[$ii],$fam_comp_flex_rmsd{$fams[$i]}{$fams[$ii]});
      }elsif(exists $fam_comp_flex_rmsd{$fams[$ii]}{$fams[$i]}){
        printf RDATA ("%s\t%s\t%.3f\n",$fams[$i],$fams[$ii],$fam_comp_flex_rmsd{$fams[$ii]}{$fams[$i]});
      }
    }
    print RDATA "\n";
  }
  
  close(RDATA);
}
##############################

##############################
## Counting real structures in Fam
## Arguments: current group, current family name
## Returns: hash containing {fam}=numb_real_structures
## 
sub count_real_structures_in_fam{
  my ($group, @fam) = (${$_[0]},@{$_[1]});
  my %fam_str_count;
  
  ######
  ## connecting DB
  my $conn = DBI->connect("dbi:Pg:dbname=hpkd_db;host=localhost;port=5433;user=malonso;password='manuel'");
  foreach my $fam (@fam){
    ## querying DB for fam real structures
    my $query = $conn->prepare("SELECT count(distinct(template_file)) FROM hpkd_templates_realseq WHERE hpkd_group='$group' AND hpkd_family = '$fam' AND need_to_model='no'")or die $conn->errstr;
    $query->execute() or die $conn->errstr;
    ## fetching names of fam real structures
    my $realstructures = scalar($query->fetchrow_array());
    $fam_str_count{$fam}=$realstructures;
  }
  ## disconnecting DB
  $conn->disconnect();
  ######
  
  return %fam_str_count;
}
##############################

##############################
## In situ hash keys renaming
##
sub rename_key {
 my $hashref = shift;
 my $oldkey  = shift;
 my $newkey  = shift;
 $hashref->{$newkey} = delete $hashref->{$oldkey};
}
##############################
