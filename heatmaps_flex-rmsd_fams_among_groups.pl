#!/usr/bin/env perl
#
# created on: 04/Jan/2011 by M.Alonso
# 
# This script generates a DATA FILE  with the AVG RMSD of the structural superpositions of all vs all families in HPKDs 
# This script must be executed from the folder that contains the among-groups fams.vs.fams str.alignments.
# This script needs access to the corresponding DATA FILEs of AVG RMSD [RIGID | FLEX] generated by within-groups str.alignments.
# After executing this script in order to generate the heatmaps you need to execute "Rheatmaps.R"
#
# ######
# INPUT: 
# - hpkd_db
# - XML files generated by "batch_prepare_rapido_scripts_fams_among_groups.pl"
# - DATA files with AVG RMSD from within-groups str.alignments.
#
# OUTPUT:
# - a DATA file containing the AVG RMSD for all vs all HPK families with at least one R3DS available
######
#
#


use DBI;
use strict;
use warnings;
use File::Find;

## Define the HPK Groups to be processed
my @hpk_groups= qw(AGC CAMK CK1 CMGC Other STE TK TKL Atypical);
my @xmls_files=();

## Defining dir where to look for avg_rmsd data from within-groups fam vs fam comparisons
my $within_groups_comp_dir = "/aloy/scratch/malonso/test/in-groups_Fam_vs_Fam/";

my %real_structures_in_fam=(); # {fam}=Numb.R3DS
my %g1_f1_g2_f2_flexrmsd=(); # {g1}{f1}{g2}{f2}=@flex_rmsd
my %g1_f1_g2_f2_avg_flexrmsd=(); # {g1}{f1}{g2}{f2}=$avg_flex_rmsd

my $ini_dir=`pwd`;
chomp($ini_dir);

## backup and remove old datafile if exists
my $outfile=$ini_dir."/DATA_FILE_AVG_RIGID_RMSD.dat";
if(-e $outfile){
  system("cp $outfile DATA_FILE_AVG_RIGID_RMSD.backup");
  unlink($outfile);
}

##############################
## Fetching the number of R3DS per HPK family in all groups
%real_structures_in_fam=real_structures_per_fam();
#print "$_\t$real_structures_in_fam{$_}\n" foreach(sort {$real_structures_in_fam{$b}<=>$real_structures_in_fam{$a}} keys %real_structures_in_fam);
##############################


##############################
## Iterating through HPK group comparison pairs
foreach my $g (@hpk_groups){
  @xmls_files=();
  %g1_f1_g2_f2_flexrmsd=();
  %g1_f1_g2_f2_avg_flexrmsd=();
  ## Defining file where to look for avg_rmsd data from within-groups fam vs fam comparisons
  my $within_groups_rmsds_file = $within_groups_comp_dir.$g."/".$g."_avg_rigidrmsd_fams_in_group.v3.Rdat";

  print "processing group $g\n";
  
  ## Independently processing Atypical group since is the last in the group array.
  if($g eq "Atypical"){
    open(F,$within_groups_rmsds_file) or die;
    open(DATA,">>$outfile") or die;
    while(<F>){
      my @tmp=split("\t",$_);
      print DATA "$g\t$tmp[0]\t$g\t$tmp[1]\t$tmp[2]\n"
    }
    close(DATA);
    close(F);
    next;
  }
  
  ## moving into current group's dir
  my $change_dir=$ini_dir."/".$g."/";
  chdir($change_dir) or die;

  ## retrieve full paths of xml files in current group's dir
  print "\tretrieving xml paths\n";
  retrieve_xmls_paths($change_dir);
  
  ## parsing xml files and loading the rmsd values into an array
  print "\tloading rmsd values\n";
  foreach my $xml (@xmls_files){
    parse_xmls_load_flex_rmsds($xml);
  }
  
  ## averaging flex_rmsd values
  print "\taveraging rmsd values\n";
  %g1_f1_g2_f2_avg_flexrmsd = avg_flex_rmsd(\%g1_f1_g2_f2_flexrmsd);
  
  ## Renaming the families keys by appending the corresponding R3DS number available for the family
 %g1_f1_g2_f2_avg_flexrmsd = renaming_families_keys_names(\%g1_f1_g2_f2_avg_flexrmsd,\%real_structures_in_fam);
  
  ## Appending within group avg_rmsd values to among groups hash
  %g1_f1_g2_f2_avg_flexrmsd = append_within_group_avg_rmsd_values(\%g1_f1_g2_f2_avg_flexrmsd,$within_groups_rmsds_file,$g);
  
  ## printing to DATA file
  print "\tprinting to data file\n";
  printout_avg_flex_rmsd_hash(\%g1_f1_g2_f2_avg_flexrmsd);
  
  ## return to initial directory
  chdir($ini_dir) or die;
}
##############################


##############################
#### SUBROUTINES #############
##############################

#############################
sub retrieve_xmls_paths{
  find(\&xml_files_paths, $_[0]);
}
#############################

#############################
sub xml_files_paths{
  my $elemento = $_;
  if (-f $elemento && $elemento =~ /\.xml$/ ){
    push(@xmls_files,$File::Find::name);
  }
}
#############################

#############################
## Parsing XML files and Loading the Flex_RMSD values into the corresponding hash 
## Flex_RMSD values are pushed into an array assigned to the corresponding {g1}{f1}{g2}{f2}
##
sub parse_xmls_load_flex_rmsds{
  my $xmlfile = $_[0];
  chomp($xmlfile);
  my @fields=();
  my ($group1, $fam1, $group2, $fam2)="";
  
  @fields = split("/", $xmlfile); ## /../../../test/TKL_IRAK__IRAK4_2nryB_vs_Atypical_PDHK__PDHK1_2q8gA.inp.xml
  @fields = split("_", $fields[-1]); ## TKL_IRAK__IRAK4_2nryB_vs_Atypical_PDHK__PDHK1_2q8gA.inp.xml
  ($group1, $fam1, $group2, $fam2)=($fields[0],$fields[1],$fields[6],$fields[7]);
  #print "$group1, $fam1, $group2, $fam2\n";  
  
  ## retrieving flex_rmsd values & pushing them into an array
  open(I,$xmlfile) or die;
  while(<I>){
    if(/<flex_rmsd>(\d+\.\d+)<\/flex_rmsd>/){
      push(@{$g1_f1_g2_f2_flexrmsd{$group1}{$fam1}{$group2}{$fam2}},$1);
      last;
    }
  }
  close(I);
}
#############################

#############################
## 
## 
sub printout_avg_flex_rmsd_hash{
  my %hash = %{$_[0]};
  
  open(DATA, ">>$outfile") or die;
  
  foreach my $g1 (sort {$a cmp $b} keys %hash){
    foreach my $f1 (sort {$a cmp $b} keys %{$hash{$g1}}){
      #print DATA "\n";
      foreach my $g2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}}){
        ## By now skip Atypical group, print it later.
        next if ($g2 eq "Atypical");
        foreach my $f2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}{$g2}}){
          print DATA "$g1\t$f1\t$g2\t$f2\t";
          printf DATA ("%.4f\n",$hash{$g1}{$f1}{$g2}{$f2});
        }
      }
      #####################
      # now print Atypical group
      foreach my $g2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}}){
        if ($g2 eq "Atypical"){
          foreach my $f2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}{$g2}}){
            print DATA "$g1\t$f1\t$g2\t$f2\t";
            printf DATA ("%.4f\n",$hash{$g1}{$f1}{$g2}{$f2});
            last;
          }
        }else{;}
      }
      #####################
      print DATA "\n";
    }
  }
  print DATA "\n";
  close(DATA);
}
#############################

#############################
## Calculating the AVG Flex_RMSD among families across HPK groups
## 
sub avg_flex_rmsd{
  my %hash = %{$_[0]};
  my %return_hash;
  
  foreach my $g1 (sort {$a cmp $b} keys %hash){
    
    my @f1 = sort {$a cmp $b} keys %{$hash{$g1}};
    
    foreach my $f1 (sort {$a cmp $b} keys %{$hash{$g1}}){
      ### artifact for setting to Zero the avg(flex_rmsd) amongst families in the same group
      ##foreach my $ff1 (sort {$a cmp $b} keys %{$hash{$g1}}){$return_hash{$g1}{$f1}{$g1}{$ff1}=0.0000;}
      #foreach (@f1){
        #$return_hash{$g1}{$f1}{$g1}{$_}=0.0000;
        ##shift(@f1);
      #}
      #shift(@f1);
      foreach my $g2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}}){
        foreach my $f2 (sort {$a cmp $b} keys %{$hash{$g1}{$f1}{$g2}}){
          my ($total,$avg_flex_rmsd,$elements)=0;
          $elements = scalar @{$hash{$g1}{$f1}{$g2}{$f2}};
          $total+=$_ foreach(@{$hash{$g1}{$f1}{$g2}{$f2}});
          $avg_flex_rmsd = $total/$elements;
          $return_hash{$g1}{$f1}{$g2}{$f2}=$avg_flex_rmsd;
        }
      }
    }
  }
  
  return (%return_hash);
}
#############################


##############################
## Counting real structures in HPK Fams
## Returns: hash containing {fam}=numb_real_structures
## 
sub real_structures_per_fam{
  my %fam_str_count;
  
  ######
  ## connecting DB
  my $conn = DBI->connect("dbi:Pg:dbname=hpkd_db;host=localhost;port=5433;user=malonso;password='manuel'");
  ## querying DB for fam real structures
  my $query = $conn->prepare("SELECT distinct(hpkd_family), count(distinct(template_file)) as rs FROM hpkd_templates_realseq WHERE need_to_model='no' GROUP BY hpkd_family ORDER BY rs DESC")or die $conn->errstr;
  $query->execute() or die $conn->errstr;
  ## fetching names of fam & numb of real structures
  while(my @row = $query->fetchrow_array()){
    $fam_str_count{$row[0]}=$row[1];
  }
  ## disconnecting DB
  $conn->disconnect();
  ######
  
  return %fam_str_count;
}
##############################

##############################
## In situ hash keys renaming
##
sub rename_key {
 my $hashref = shift;
 my $oldkey  = shift;
 my $newkey  = shift;
 $hashref->{$newkey} = delete $hashref->{$oldkey};
}
##############################

##############################
## Renaming the families keys in %g1_f1_g2_f2_avg_flexrmsd by adding the corresponding R3DS number {FamA_(No.R3DS)}
##
## Arguments:
## 1) hash to be renamed (%g1_f1_g2_f2_avg_flexrmsd)
## 2) hash containing the number of R3DS per HPK family (%real_structures_in_fam)
## 
## Returns:
## The hash of argument 1 (%g1_f1_g2_f2_avg_flexrmsd) with families keys renamed
##
sub renaming_families_keys_names{
  my %renamedkeys=%{$_[0]};
  my %fam_str_count=%{$_[1]};
  my ($g1,$f1,$g2,$f2,$newkey)="";
  
  ## Renaming the keys in %fam_comp_flex_rmsd by adding the corresponding R3DS number
  ## Renaming f1 keys {g1}{f1}
  foreach $g1 (keys %renamedkeys){
    foreach $f1 (keys %{$renamedkeys{$g1}}){
      $newkey=$f1."_(".$fam_str_count{$f1}.")";
      rename_key( \%{$renamedkeys{$g1}}, $f1, $newkey);
    }
  }
  foreach $g1 (keys %renamedkeys){
    foreach $f1 (keys %{$renamedkeys{$g1}}){
      foreach $g2 (keys %{$renamedkeys{$g1}{$f1}}){
        foreach $f2 (keys %{$renamedkeys{$g1}{$f1}{$g2}}){
          my $newkey=$f2."_(".$fam_str_count{$f2}.")";
          rename_key( \%{$renamedkeys{$g1}{$f1}{$g2}}, $f2, $newkey);
        }
      }
    }
  }

  ## Debugging printing of data structure in %renamedkeys
  #foreach $g1 (keys %renamedkeys){
    #foreach $f1 (keys %{$renamedkeys{$g1}}){
      #foreach $g2 (keys %{$renamedkeys{$g1}{$f1}}){
        #foreach $f2 (keys %{$renamedkeys{$g1}{$f1}{$g2}}){
          #print "$g1\t$f1\t$g2\t$f2\n";
        #}
      #}
    #}
  #}
  
  return %renamedkeys;
  
}
##############################

##############################
sub append_within_group_avg_rmsd_values{
  my %g1_f1_g2_f2_avg_rmsd = %{$_[0]};
  my $within_groups_rmsds_file = $_[1];
  my $group = $_[2];

  open(F,$within_groups_rmsds_file) or die;
  while(<F>){
    chomp();
    if($_ eq ""){
      next;
    }else{
      my @fields = split("\t",$_); ## FAM1_(R3DS) FAM2_(R3DS) AVGRMSD
      $g1_f1_g2_f2_avg_rmsd{$group}{$fields[0]}{$group}{$fields[1]}=$fields[2];
    }
  }
  close(F);
  
  return %g1_f1_g2_f2_avg_rmsd;
}
##############################













