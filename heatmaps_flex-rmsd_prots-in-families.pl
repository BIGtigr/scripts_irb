#!/usr/bin/env perl
#
# Dic.2010 by MAlonso
#
# Processing RAPIDO's xml output files from the pairwise structural superposition of R3DS.hpkds
# among families of the same HPK group.
#
# The script generates (for each family pairwise comparison):
#   - a gnuplot data file
#   - a gnuplot script file
#   - a heatmap.eps file
#
# The script's sequence of actions is:
# Reading XMLs files of all structural superpositions. 
# Generating the corresponding gnuplot data files & script files.
# Executing gnuplot script files
#
# This script is intended to be used after performing all the struc.aligments with RAPIDO (script: "batch_prepare_rapido_scripts.pl").
# This script must be executed from the folder that contains the folder directories structure created by "batch_prepare_rapido_scripts.pl"
#
# For more info read the README file present in the same folder afore mentioned.
#
######
# INPUT: 
# XML files generated by RAPIDO after each protA vs protB structural superposition
#
# OUTPUT:
# The script generates (for each family pairwise comparison):
#   - a gnuplot data file
#   - a gnuplot script file
#   - a heatmap.eps file
######
#
use strict;
use warnings;
use File::Find;


## RGC neither Atypical groups were included in the current analysis
## due to they only contain one family (or none) for which Real3DStrs are
## available (histogram: dist_strs-templs_per_hpkfamily.pdf)

#my @hpk_groups= qw(AGC CAMK CK1 CMGC Other STE TK TKL Atypical);
my @hpk_groups= qw(STE);
my (@fam1,@fam2);
my %strs_flex_rmsd=();
my @xmls_files=();

my $ini_dir=`pwd`;
chomp($ini_dir);


## iterating trough each HPK group
foreach my $group (@hpk_groups){
  print "processing group $group\n";
  my @fam_comp_folders;
  ## moving into current GROUP directory
  my $change_dir=$ini_dir."/".$group."/";
  chdir($change_dir) or die;
  #system ("pwd");
  
  ## loading families comparison folders 
  opendir(DIR, $change_dir) or die "cant find $change_dir: $!";
  while (defined(my $file = readdir(DIR))) {
    next if $file =~ /^\.\.?$/;
    push @fam_comp_folders,"$change_dir$file" if (-d "$change_dir$file");
  }#print "$_\n" foreach (@fam_comp_folders);
  closedir(DIR);  
  
  foreach my $folder (@fam_comp_folders){
    print "\t$folder\n";
    ## defining data structure for storing the flex_rmsd values of each fam-fam struc superposition
    %strs_flex_rmsd=(); # {FamA-ProtX}{FamB-ProtY}=flex_rmsd
    @xmls_files=();
    my $current_dir="";
    my ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_flex_rmsd, $min_flex_rmsd, $FamA_name, $FamB_name) = "";
    ## cd into current $foder of family comp pair
    chdir($folder);
    ## retrieve the current full path
    $current_dir=`pwd`;
    chomp($current_dir);
    
    ### Retrieve full paths of xml files $current_dir of family comp pairs
    ### Storing them in @xmls_files
    retrieve_xmls_paths($current_dir);
    
    ## Parsing XML files and creating Gnuplot DATA file
    unless($#xmls_files>=0){
      print "\t\t not enough structures for alignments. Skipping current comparision folder\n";
      next;
    }
    ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_flex_rmsd, $min_flex_rmsd, $FamA_name, $FamB_name) = parse_xmls_create_gnuplot_datafile(@xmls_files);
    #generate_gnuplot_script($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_flex_rmsd, $min_flex_rmsd, $FamA_name, $FamB_name, $group);
    
    ## execute gnuplot scripts
    #system("gnuplot GNUPLOT_SCRIPT.gplot");

    ## go back one dir
    chdir("../");
    #system ("pwd");
  }
  ## go back to starting directory
  chdir($ini_dir);
  #system ("pwd");
}


##############################
#### SUBROUTINES #############
##############################

#############################
sub retrieve_xmls_paths{
  my $current_dir="";
  $current_dir = $_[0];
  #print "-$current_dir\n";
  find(\&xml_files_paths, $current_dir);
}
#############################

#############################
sub xml_files_paths{
  my $elemento = $_;
  if (-f $elemento && $elemento =~ /\.xml$/ ){
    #print "$File::Find::name\n";
    push(@xmls_files,$File::Find::name);
  }
}
#############################


#############################
## Parsing XML files & creating GnuPlot Data file
##
sub parse_xmls_create_gnuplot_datafile{
  # pase xml files and fill hash {str1}{str2}=flex_rmsd
  my @xmls = @_;
  my (@fields,@prot1,@prot2);
  my ($flex_rmsd,$prot1,$prot2,$FamA_name,$FamB_name);
  my ($indexA,$indexB,$prots_in_FamA,$prots_in_FamB)=0;
  my $xtics="";
  my $ytics="";
  my $max_flex_rmsd=-1;      ## I'm currently collecting max & min flex_rmsd but I'm not using them.
  my $min_flex_rmsd=999999;  ## They were/are intended to be used for setting the min-max threshold of cbrange (color-box range).
  
  
  open(DATAFILE,">GNUPLOT_DATA_FILE.dat") or die;
  
  foreach my $xmlfile (@xmls){
    chomp($xmlfile);
    ## retrieving flex_rmsd values
    open(I,$xmlfile) or die;
    while(<I>){
      if(/<flex_rmsd>(\d+\.\d+)<\/flex_rmsd>/){
      #if(/<rmsd>(\d+\.\d+)<\/rmsd>/){
        $flex_rmsd = $1;
        $max_flex_rmsd = $flex_rmsd if($flex_rmsd > $max_flex_rmsd);
        $min_flex_rmsd = $flex_rmsd if($flex_rmsd < $min_flex_rmsd);
        last;
      }
    }
    close(I);

    $xmlfile =~ /.*\/(.*)\.inp\.xml$/;
    $xmlfile = $1;
    @fields = split("_vs_",$xmlfile);
    # G_F_SF_PK_PDB
    @prot1 = split("_",$fields[0]);
    @prot2 = split("_",$fields[1]);
    $prot1 = join("_-",@prot1[3..4]);
    $prot2 = join("_-",@prot2[3..4]);
    $strs_flex_rmsd{$prot1}{$prot2}=$flex_rmsd;
    $FamA_name=$prot1[1];
    $FamB_name=$prot2[1];    
  }
  
  foreach my $k1 (sort {$a cmp $b} keys %strs_flex_rmsd){
    $xtics=$xtics."\"$k1\" $indexA,";
    $indexB=0;
    $ytics="";
    #unless((keys %strs_flex_rmsd)>1){$indexA++; $xtics=$xtics."\"\" $indexA,";}
    foreach my $k2 (sort {$a cmp $b} keys %{$strs_flex_rmsd{$k1}}){
      $ytics=$ytics."\"$k2\" $indexB,";
      #unless((keys %{$strs_flex_rmsd{$k1}})>1){$indexB++; $ytics=$ytics."\"\" $indexB,";}
      print DATAFILE "$FamA_name\t$k1\t$FamB_name\t$k2\t$indexA\t$indexB\t$strs_flex_rmsd{$k1}{$k2}\n";
      ### dealing with families with only 1 Real3DStr
      unless((keys %strs_flex_rmsd)>1){
        #$indexA;
        #$xtics=$xtics."\"$k1\" $indexA,";
        print DATAFILE "$FamA_name\t----------\t$FamB_name\t$k2\t1\t$indexB\t0.00\n\n";
      }
      ### dealing with families with only 1 Real3DStr
      unless((keys %{$strs_flex_rmsd{$k1}})>1){
        #$indexB++;
        #$ytics=$ytics."\"$k2\" $indexB,";
        print DATAFILE "$FamA_name\t$k1\t$FamB_name\t----------\t$indexA\t1\t0.00\n\n";
      }
      $indexB++;
    }
    $indexA++;
    print DATAFILE "\n";
  }
  chop($xtics);
  chop($ytics);
  $prots_in_FamA=$indexA;
  $prots_in_FamB=$indexB;
  #print "famA: $prots_in_FamA\n";
  #print "famB: $prots_in_FamB\n";
  #print "max flex_rmsd: $max_flex_rmsd\n";
  #print "min flex_rmsd: $min_flex_rmsd\n";
  #print "xtics: $xtics\n";
  #print "ytics: $ytics\n";
  close(DATAFILE);
  
  
  return($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_flex_rmsd, $min_flex_rmsd, $FamA_name, $FamB_name);
}
#############################

#############################
## Creating GnuPlot Script file
##
sub generate_gnuplot_script{
  my $gnuplot_template="/home/malonso/phd/kinome/scripts/heatmaps_flex-rmsd_prots-in-families_TEMPLATE.gplot";
  my ($xtics, $ytics, $prots_in_FamA, $prots_in_FamB, $max_flex_rmsd, $min_flex_rmsd, $FamA_name, $FamB_name, $group) = @_;
  
  open(GNUPLOT,$gnuplot_template) or die;
  my @gnuplot_template=<GNUPLOT>;
  close(GNUPLOT);
  
  open(GNUPLOT_SCRIPT,">GNUPLOT_SCRIPT.gplot") or die;
  
  my @gnuplot_template_cp = @gnuplot_template;
  
  foreach (@gnuplot_template_cp){
    if(/HPK-GROUP/){
      s/HPK-GROUP/$group/;
    }elsif(/FAMILY-A/){
      s/FAMILY-A/$FamA_name/;
    }elsif(/XTICS_LABELS/){
      s/XTICS_LABELS/$xtics/;
    }elsif(/XTOP_VALUE/){
      $prots_in_FamA = $prots_in_FamA - 0.5;
      s/XTOP_VALUE/$prots_in_FamA/;
    }elsif(/FAMILY-B/){
      s/FAMILY-B/$FamB_name/;
    }elsif(/YTICS_LABELS/){
      s/YTICS_LABELS/$ytics/;
    }elsif(/YTOP_VALUE/){
      $prots_in_FamB = $prots_in_FamB - 0.5;
      s/YTOP_VALUE/$prots_in_FamB/;
    #}elsif(/_RMSD_VALUE/){
      #$min_flex_rmsd = $min_flex_rmsd - 0.05;
      #s/BOTTOM_RMSD_VALUE/$min_flex_rmsd/;
      #$max_flex_rmsd = $max_flex_rmsd + 0.05;
      #s/TOP_RMSD_VALUE/$max_flex_rmsd/;
    }elsif(/HEAT_MAP_NAME/){
      my $heat_map = $FamA_name."_vs_".$FamB_name;
      s/HEAT_MAP_NAME/$heat_map/;
    }
    print GNUPLOT_SCRIPT "$_";
  }
  
  close(GNUPLOT_SCRIPT);
}
#############################



