# created on: 19/Dec/2011 by M.Alonso
#
# USAGE:
#   PERL5LIB env variable:
#    update PERL5LIB variable in .bashrc
#    export PERL5LIB=${PERL5LIB}:/home/malonso/phd/kinome/scripts/modules/
#
# CALLING MODULE
#   use SIFsUtils;
#

use strict;
use warnings;
use List::MoreUtils qw(uniq);

use LoadFile;

require Exporter;
package SIFsUtils;

our @ISA       = qw(Exporter);
our @EXPORT    = qw(
                      acs_pin_from_sif
                      pin2file
                      sif2HoH
                    );
#

##############################
######## SUBROUTINES ######### 
##############################

##############################
### Description:
###   - Function called from 'pin2file'
###   - Generate single SIF file merging PPIs from each independent AC in the datastructure {AC}=[PPI, PPI, PPI]
###   
### Input
###   - Ref. to a hash of array containing the PINs of seed proteins  ( {AC}=[PPI, PPI, PPI] )
###   - Full path to output directory (/path/to/dir)
###   
### Returns
###   - Writes a single output SIF file.
###   
### Usage:
###   print_merged_sif(\%acs_pins, "/path/to/outdir")
###   
sub print_merged_sif_file{
  my %tmp = %{$_[0]};
  my $outdir = $_[1];
  my $outfilename;
  my @ppis; 
  
  ### Printing merged SIF file
  print "Printing merged SIF file\n";
  
  ### Making PPIs unique.
  foreach my $ac (keys %tmp) {
    push(@ppis, @{$tmp{$ac}});
  }
  @ppis = uniq(@ppis);
  
  ### Printing to file 
  $outfilename = $outdir."/"."merged_SIF".".sif";
  open(O, ">$outfilename") or die;
  foreach (@ppis) { print O "$_\n"; }
  close(O);
}
##############################

##############################
### Description:
###   - Function called from 'pin2file'
###   - Generate SIF file for each independent AC in the datastructure {AC}=[PPI, PPI, PPI]
###   
### Input
###   - Ref. to a hash of array containing the PINs of seed proteins  ( {AC}=[PPI, PPI, PPI] )
###   - Full path to output directory (/path/to/dir)
###   
### Returns
###   - Writes output SIF files.
###   
### Usage:
###   print_independent_sifs(\%acs_pins, "/path/to/outdir")
###   
sub print_independent_sif_files{
  my %tmp = %{$_[0]};
  my $outdir = $_[1];
  my $outfilename;
  
  ### Printing independent SIF files
  print "Printing independent SIF files\n";
  
  foreach my $ac (keys %tmp) {
    $outfilename = $outdir."/".$ac.".sif";
    open(O, ">$outfilename") or die;
    foreach ( @{$tmp{$ac}} ){
      print O "$_\n";
    }
    close(O);
  }
}
##############################

##############################
### Description:
###   - Writes PIN to SIF files.
###   - Output can be written to independent files, a single merged file or both.
###   - Uses as input the datastructure generated by the subroutine 'acs_pin_from_sif' {AC}=[PPI, PPI, PPI].
###   
### Input
###   - Ref. to a hash of array containing the PINs of seed proteins  {AC}=[PPI, PPI, PPI].
###   - Type of output file [I | M | B]:
###     - I: An independent SIF file of PPIs for each {AC}
###     - M: A merged file containing all PPIs from all {AC}
###     - B: Both previous output files will be generated
###   - Full path to output directory
###     - /path/to/dir
###   
### Returns
###   - Writes output SIF files.
###   - If 'I' is specified as output type, output files containing 
###     the PIN of each seed AC will be written and named after the 
###     corresponding AC.
###   - If 'M' is specified as output type, a single output file containing 
###     the PIN of all seed ACs will be written.
###   - If 'B' is specified as output type, both previous outputs will be
###     generated.
###   
###   
### Usage:
###   pin2file(\%acs_pins, [ I | M | B ], "/path/to/outdir/")
###   
sub pin2file{
  
  ### Fetching arguments
  my %hoa = %{$_[0]}; ### {AC}=[PPI, PPI, PPI]
  my $outfile_type = $_[1];   ### [I | M | B]
  my $outdir = $_[2]; ### Full path to output directory
  
  my $outfilename;
  
  ### Checking input arguments
  ### Checking proper output file
  die "Please provide correct ouput file type: [I | M | B]\n" unless ( grep {$outfile_type eq $_} qw(I M B) );
  ### Checking | Creating output directory
  unless( -e $outdir ){
    mkdir($outdir) || die "Can not create ouput directory $outdir\n";
  }
  
  if($outfile_type eq "I"){
    print_independent_sif_files(\%hoa,$outdir);
  }elsif($outfile_type eq "M"){
    print_merged_sif_file(\%hoa,$outdir);
  }elsif($outfile_type eq "B"){
    print_merged_sif_file(\%hoa,$outdir);
    print_independent_sif_files(\%hoa,$outdir);
  }
  
}
##############################


##############################
### Description:
###   Given a list of Uniprot ACs, it retrieves the corresponding PIN
###   using a source SIF file.
###   
### Input
###   - Full path to SIF file containing the target interactome
###   - Ref. to array containing the list of query ACs
###   - An integer [1|2] specifying wether you want to fetch 1st or 2nd
###      level neighbors.
###   
### Returns
###   - Ref. to hash of array containing the PIN for each seed protein provided. {seedAC}=[PPI, PPI, PPI]
###   
### Usage:
###   %hoa = %{ acs_pin_from_sif( infile, \@queryacs, 1|2 ) }
###   
###   
sub acs_pin_from_sif{
  
  ### Input arguments
  my $input_sif_file = $_[0];### AC AC
  my @queryacs = @{$_[1]}; ### [ACs]
  my $pin_level = $_[2]; ### [I|M|B]
  
  ### Other variables
  my @input_sif_file; ### Storing input interactome in an array
  
  ### Output hash of array
  ### {seedAC}=[PPI, PPI, PPI]
  my %seeds_pins; 
  
  ### Controlling input arguments
  die "Input SIF file does not exist\n" unless (-e $input_sif_file);
  die "No query ACs provided\n" unless (0 < scalar @queryacs);
  die "Please provide a correct neighbors level: 1|2\n" unless ($pin_level == 1 || $pin_level == 2);
  
  ### Loading input SIF file to an array
  @input_sif_file = LoadFile::File2Array($input_sif_file);
  
  ### Fetching PINs
  if($pin_level == 1){ ### 1st level neighbors
    foreach my $ac (@queryacs){
      @{$seeds_pins{$ac}} = @{ neighbours_1st_level($ac, \@input_sif_file) };
    }
  }elsif($pin_level == 2){ ### 2nd level neighbors
    foreach my $ac (@queryacs){
      @{$seeds_pins{$ac}} = @{ neighbours_2nd_level($ac, \@input_sif_file) };
    }
  }
  return \%seeds_pins;
}
##############################

##############################
### Description:
###   Subroutine used by the caller subroutine 'acs_pin_from_sif'.
###   Given a Uniprot AC, it retrieves the 1st level PIN using a source SIF file.
###   
### Input
###   - Query AC
###   - Ref. to an array containing the reference interactome [PPI, PPI, PPI]
###   
### Returns
###   - Ref. to an array containing the PIN for the query AC provided [PPI, PPI, PPI]
###   
### Usage:
###   @pin = @{ neighbours_1st_level(queryAC, \@ReferenceInteractome) }
###   
###   
sub neighbours_1st_level{
  use List::MoreUtils qw(uniq);
  ### Taking arguments
  my $queryAC = $_[0];
  my @ref_interactome = @{$_[1]};
  
  ### Defining variables
  my $ppi_pair;
  my @ppi_network; ### Output array. [PPI, PPI]
  my @ppi_partners;
  
  
  ########## FIRST NEIGHBOURS
  foreach(@ref_interactome){
    @ppi_partners = LoadFile::splittab($_);
    
    if( grep { $queryAC eq $_ } @ppi_partners){
      $ppi_pair=LoadFile::jointab(sort @ppi_partners);
      push (@ppi_network, $ppi_pair);
    }
  }
  @ppi_network = uniq(@ppi_network);
  ##########
  
  return \@ppi_network;
}
##############################

##############################
### Description:
###   Subroutine used by the caller subroutine 'acs_pin_from_sif'.
###   Given a Uniprot AC, it retrieves the 2nd level PIN using a source SIF file.
###   
### Input
###   - Query AC
###   - Ref. to an array containing the reference interactome [PPI, PPI, PPI]
###   
### Returns
###   - Ref. to an array containing the PIN for the query AC provided [PPI, PPI, PPI]
###   
### Usage:
###   @pin = @{ neighbours_2nd_level(queryAC, \@ReferenceInteractome) }
###   
###   
sub neighbours_2nd_level{
  use List::MoreUtils qw(uniq);
  ### Taking arguments
  my $queryAC = $_[0];
  my @ref_interactome = @{$_[1]};
  
  ### Defining variables
  my $ppi_pair;
  my @ppi_network; ### Output array. [PPI, PPI]
  my @secondary_seeds; ### Seeds for 2nd level neighbors
  my @ppi_partners;
  
  ########## FIRST NEIGHBOURS
  foreach(@ref_interactome){
    @ppi_partners = LoadFile::splittab($_);
    if( grep { $queryAC eq $_ } @ppi_partners){
      $ppi_pair=LoadFile::jointab(sort @ppi_partners);
      push (@ppi_network, $ppi_pair);
      push(@secondary_seeds, $ppi_partners[0]) if ($ppi_partners[0] ne $queryAC); ## storing seed nodes for 2nd-level neighbourhood
      push(@secondary_seeds, $ppi_partners[1]) if ($ppi_partners[1] ne $queryAC); ## storing seed nodes for 2nd-level neighbourhood
    }
  }
  @secondary_seeds = uniq(@secondary_seeds);
  ##########
  
  ########## SECOND NEIGHBOURS
  foreach my $secQueryAC (@secondary_seeds){
    foreach(@ref_interactome){
      @ppi_partners = LoadFile::splittab($_);
      if( grep { $secQueryAC eq $_ } @ppi_partners ){
        $ppi_pair=LoadFile::jointab(sort @ppi_partners);
        push (@ppi_network, $ppi_pair);
      }
    }
  }
  @ppi_network = uniq(@ppi_network);
  ##########
  
  return \@ppi_network;
}
##############################

#############
### Stores a SIF file (PPI) into a hash of hash.
### Input:
###   Path to a file with the format: PROTEIN-1 PROTEIN-2
### Returns:
###  A reference to a hash of hash: {AC}{AC}=1
###
sub sif2HoH{
  my $path_to_sif_file = $_[0];
  my @fields;
  my %sifHoH;
  print "Loading sif file\n";
  foreach(LoadFile::File2Array($path_to_sif_file)){
    @fields = LoadFile::splittab($_);
    $sifHoH{$fields[0]}{$fields[1]}=1;
  }
  return \%sifHoH;
}
#############

1;
